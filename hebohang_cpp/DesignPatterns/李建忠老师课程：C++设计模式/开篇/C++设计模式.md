# C++设计模式


“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”
“Any problem in computer science can be solved by another layer of indirection.”

# 设计模式简介


### 什么是设计模式？

“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。”

——Christopher Alexander

### GOF设计模式

其实GOF就是历史性著作《设计模式：可复用面向对象软件的基础》的四位作者（合称"Gang of Four"）。

其实这本书副标题更重要：可复用面向对象软件的基础。

可复用是设计模式的目标，而面向对象是我们的手法。可复用和面向对象乃两个关键词。

### 从面向对象谈起

抽象思维同样重要，其核心是帮助我们能更好地管理代码复杂度，当然底层思维是重要的，两个思维需要并重，但是单论设计模式而言更偏向学习抽象思维：


### 软件设计复杂的根本原因与解决方法

根本原因就是变化：

客户需求的变化、技术平台的变化、开发团队的变化、市场环境的变化



解决方法：

分解（分而治之）与抽象。所有设计模式都是围绕抽象这么一个关键词来进行各种各样的变化。



**设计模式最关键的不是掌握一堆代码的技巧，而是建立一套思维的方式和模型。**



面向对象设计最大的优势在于：抵御变化！



### 软件设计的目标

什么是好的软件设计？复用！


# 面向对象设计原则

### 重新认识面向对象

![image-20211018231228608](https://user-images.githubusercontent.com/60227429/138050274-244a757c-75d6-4b2f-9514-41092b418110.png)!


责任是思考类设计的一个非常重要的观点。



### 示例

比方说现在有一个画布类MainForm，需要在其上画一些形状，现成的有线类class Line、矩形类class Rect，一种直观的分解做法就是：画布类封装两个vector，一个存Line一个存Rect，然后在画布类调用画的函数OnPaint的时候，分别遍历这两个vector去进行绘制：

```cpp
void MainForm::OnPaint(const PaintEventArgs& e){

	//针对直线
	for (int i = 0; i < lineVector.size(); i++){
		e.Graphics.DrawLine(Pens.Red,
			lineVector[i].start.x, 
			lineVector[i].start.y,
			lineVector[i].end.x,
			lineVector[i].end.y);
	}

	//针对矩形
	for (int i = 0; i < rectVector.size(); i++){
		e.Graphics.DrawRectangle(Pens.Red,
			rectVector[i].leftUp,
			rectVector[i].width,
			rectVector[i].height);
	}
	circleVector[i]);
	}

	//...
	Form::OnPaint(e);
}
```

以上就为示例代码，展示的是分解的思想。用前面所述的观点来看，”画“这样一个责任，在这个方法中分配给了画布，由画布类去进行绘制。



但是还记得我们之前说的么？软件设计复杂的根本原因就是变化。如果这时候不只直线类和矩形类，再加一个圆形类class Circle，那会怎样呢？



很明显我们此时需要改多个地方——在MainForm中封装一个 vector<Circle> ，在OnPaint中专门针对圆形去绘制，同时如果还有其他的函数也很可能要有相应的更改。



但是对于一个抽象的做法来说，我们弄一个抽象类shape，而Line、Rect、Circle等等类去继承它。此时调用权（责任）就在每一个shape子类自己本身，而MainForm则只需封装一个vector<Shape*> shapeVector，这就是所谓的”各负其责“ ：

```cpp
void MainForm::OnPaint(const PaintEventArgs& e){

	//针对所有形状
	for (int i = 0; i < shapeVector.size(); i++){

		shapeVector[i]->Draw(e.Graphics); //多态调用，各负其责
	}

	//...
	Form::OnPaint(e);
}
```

同样这里我们看到，在抽象的方法中，我们vector内部存储了shape指针，而分解的方法中却存着非指针，为什么呢？因为在这个例子的抽象方法中，我们需要用到多态性质，所以必须存指针。

> 还记得我们之前说的动态绑定吗？其有三个原则：1. 通过指针 2. 这个指针向上转型（up-cast），这保证安全 3. 调用的是虚函数。这里存着Shape*，而存进去的可以是 Line\* 也可以是 Rect\* ，向上转型成 Shape\* ，实现动态绑定。

 

## 面向对象八大设计原则

其实设计原则比模式更重要。所有的设计模式都是依赖设计原则的，如果不符合这个模式就是错误的。

### 1. 依赖倒置原则（DIP）

- 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。 

- 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。

回到我们之前讲的例子，高层模块是MainForm，其应当是稳定的；而基层模块是Line、Rect这些，但是在分解法中却有如下依赖关系：

（这里我就非常简略地画一下关系了（[Untitled Diagram - VP Online (visual-paradigm.com)](https://online.visual-paradigm.com/app/diagrams/)））：



![image-20211018234750685](https://user-images.githubusercontent.com/60227429/138050648-ec85e373-aa99-4cd4-a167-470de86b9bf2.png)

MainForm依赖于Line和Rect，这违反了依赖倒置原则：高层模块(稳定)依赖于低层模块(变化)



而第二种方式则做了一个中间（抽象）层：

![image-20211018235153858](https://user-images.githubusercontent.com/60227429/138050731-433accda-28a4-485c-81f5-d5fe79d608ca.png)


他们都依赖一层抽象Shape（MainForm中有vector<Shape*>，而Line和Rect则直接继承自Shape），并且抽象Shape不依赖于实现细节，即不依赖Line和Rect这些，而实现细节依赖于抽象。因此这里实现了一个隔离变化（把Line、Rect这样的变化隔离出来了），符合依赖倒置原则。



依赖倒置原则是一个非常重要的设计原则，其几乎贯穿了整个设计模式。

### 2. 开放封闭原则（OCP）

- 对扩展开放，对更改封闭。
- 类模块应该是可扩展的，但是不可修改。

继续刚才的例子，在第二种设计方法，当我们需要增加一个绘制圆Circle的需求的时候，就可以直接增加一个Circle类去进行扩展。



### 3. 单一职责原则（SRP）

- 一个类应该仅有一个引起它变化的原因。
- 变化的方向隐含着类的责任。

在Bridge（桥接）和Decorator（装饰）模式都会遇到类的责任的问题。在一些特定的场合类的责任显得尤为重要，稍有不慎就会遇到一些坑，而单一职责原则可以帮助我们梳理这方面。



### 4. Liskov 替换原则（LSP）

- 子类必须能够替换它们的基类(IS-A)。
- 继承表达类型抽象。

如果B是A的子类，那么所有需要A的地方，将B传过去都应该要可以使用。

在具体实现中有的人可能会打破这个原则。比如有的人把A的一些方法，在B继承的时候就搞得不可用了，那么在子类这三个方法里头就很可能会直接抛出异常。其实就是违反了子类可以替换父类的原则。



### 5. 接口隔离原则（ISP）

- 不应该强迫客户程序依赖它们不用的方法。
- 接口应该小而完备。

所谓小就是不要把不必要的方法public出去。真正有必要的时候才暴露出去。否则很容易让客户程序（即使用它的程序）跟它产生依赖，一旦产生依赖接口就需要保持稳定性。



### 6. 优先使用对象组合，而不是类继承

- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。 
- 继承在某种程度上破坏了封装性，子类父类耦合度高。 
- 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

最准确的继承应当是类属关系（is a），比如汽车 is a 交通工具。因此很多时候继承是不适用的，子类父类耦合度过高。

> 在《游戏编程模式》一书的第五页，作者给出了解耦的两个定义。第一种定义：如果两块代码耦合，意味着必须同时了解两块代码。如果解耦，那么只需了解其一。第二种定义：对解耦的另一个定义就是当改变了一块代码时不必更改另外一块代码。



### 7. 封装变化点

- 使用封装来创建对象之间的分界层，让设计者可以在分界层的 一侧进行修改，而不会对另一侧产生不良的影响，从而实现层 次间的松耦合。

当设计的素养逐步提升的时候，应当能够在软件领域能够划分出所谓的分解层。从传统的OO角度理解封装就是封装代码和数据，但是从更高角度理解是封装变化点——一侧变化一侧稳定。



### 8. 针对接口编程，而不是针对实现编程

- 不将变量类型声明为某个特定的具体类，而是声明为某个接口。 （当然这里不是绝对化的，更加的是指那些业务类型）
- 客户程序无需获知对象的具体类型，只需要知道对象所具有的 接口。 
- 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合” 的类型设计方案。

比如前面的例子，放入了抽象接口shape，然后在具体处理的时候只使用接口的通用方法（shape->Draw）去处理就好了。



这其中很多原则是相辅相成的，往往违背一个的同时还可能会违背其他的。



## 面向接口编程

![image-20211019001911832](https://user-images.githubusercontent.com/60227429/138050779-c07fe47c-63c5-48b6-8ff5-635bcd663f48.png)




李建忠老师给了一个很有趣的例子：紧耦合设计就像雕版印刷，而松耦合设计就像活字印刷。活字印刷也是一种面向接口设计。



## 将设计原则提升为设计经验

1. 设计习语 Design Idioms
   - Design Idioms 描述与特定编程语言相关的低层模式，技巧， 惯用法。 
2. 设计模式 Design Patterns
   - Design Patterns主要描述的是“类与相互通信的对象之间的组 织关系，包括它们的角色、职责、协作方式等方面。 
3. 架构模式 Architectural Patterns 
   - Architectural Patterns描述系统中与基本结构组织关系密切的 高层模式，包括子系统划分，职责，以及如何组织它们之间关 系的规则

只有深入领会了八大设计原则，才能非常灵活地理解和运用具体的某个模式。





